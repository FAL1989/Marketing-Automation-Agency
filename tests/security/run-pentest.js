const { execSync } = require('child_process');
const axios = require('axios');
const fs = require('fs').promises;

const BASE_URL = process.env.BASE_URL || 'http://localhost:8000';

async function runPenetrationTests() {
  console.log('Iniciando testes de penetração...\n');
  
  const results = {
    timestamp: new Date().toISOString(),
    vulnerabilities: [],
    summary: {
      high: 0,
      medium: 0,
      low: 0
    }
  };

  try {
    // 1. Executar verificações de segurança básicas
    console.log('Executando verificações de segurança básicas...');
    const securityChecks = require('./security-checks');
    const securityResults = await securityChecks.runSecurityChecks();
    results.vulnerabilities.push(...securityResults.vulnerabilities);

    // 2. Verificar portas abertas
    console.log('\nVerificando portas abertas...');
    try {
      const ports = [80, 443, 8000, 8080, 3000, 5432, 6379];
      for (const port of ports) {
        try {
          await axios.get(`http://localhost:${port}`);
          results.vulnerabilities.push({
            type: 'open_port',
            severity: 'medium',
            description: `Porta ${port} está aberta e acessível`,
            recommendation: 'Fechar portas não utilizadas ou restringir acesso'
          });
        } catch (error) {
          // Porta fechada ou não acessível
        }
      }
    } catch (error) {
      console.log('Erro ao verificar portas:', error.message);
    }

    // 3. Verificar configurações de CORS
    console.log('\nVerificando configurações de CORS...');
    try {
      const corsResponse = await axios.get(`${BASE_URL}/api/health`, {
        headers: {
          'Origin': 'http://malicious-site.com'
        }
      });
      
      if (corsResponse.headers['access-control-allow-origin'] === '*') {
        results.vulnerabilities.push({
          type: 'cors_misconfiguration',
          severity: 'high',
          description: 'CORS está configurado de forma muito permissiva',
          recommendation: 'Restringir CORS para origens específicas'
        });
      }
    } catch (error) {
      // CORS bloqueado como esperado
    }

    // 4. Testar proteção contra XSS
    console.log('\nTestando proteção contra XSS...');
    const xssPayloads = [
      '<script>alert("xss")</script>',
      '"><script>alert("xss")</script>',
      '"><img src=x onerror=alert("xss")>',
      '{{constructor.constructor("alert("xss")")()}}'
    ];

    for (const payload of xssPayloads) {
      try {
        const response = await axios.post(`${BASE_URL}/api/content`, {
          content: payload
        });

        if (response.data.includes(payload)) {
          results.vulnerabilities.push({
            type: 'xss_vulnerability',
            severity: 'high',
            description: 'Endpoint vulnerável a XSS',
            payload,
            recommendation: 'Implementar sanitização de entrada e CSP'
          });
        }
      } catch (error) {
        // Erro 400 é esperado para payloads maliciosos
      }
    }

    // 5. Testar proteção contra SQL Injection
    console.log('\nTestando proteção contra SQL Injection...');
    const sqlPayloads = [
      "' OR '1'='1",
      "'; DROP TABLE users; --",
      "' UNION SELECT * FROM users; --",
      "' OR 1=1; --"
    ];

    for (const payload of sqlPayloads) {
      try {
        const response = await axios.get(`${BASE_URL}/api/users?search=${payload}`);
        
        if (response.status === 200) {
          results.vulnerabilities.push({
            type: 'sql_injection',
            severity: 'high',
            description: 'Endpoint potencialmente vulnerável a SQL Injection',
            payload,
            recommendation: 'Usar prepared statements e validação de entrada'
          });
        }
      } catch (error) {
        // Erro 400 é esperado para payloads maliciosos
      }
    }

    // 6. Verificar vazamento de informações
    console.log('\nVerificando vazamento de informações...');
    try {
      const errorResponse = await axios.get(`${BASE_URL}/api/nonexistent`);
      
      if (errorResponse.data?.stack || errorResponse.data?.includes('Error:')) {
        results.vulnerabilities.push({
          type: 'information_disclosure',
          severity: 'medium',
          description: 'Stacktrace exposto em mensagens de erro',
          recommendation: 'Sanitizar mensagens de erro em produção'
        });
      }
    } catch (error) {
      if (error.response?.data?.stack || error.response?.data?.includes('Error:')) {
        results.vulnerabilities.push({
          type: 'information_disclosure',
          severity: 'medium',
          description: 'Stacktrace exposto em mensagens de erro',
          recommendation: 'Sanitizar mensagens de erro em produção'
        });
      }
    }

    // Calcular sumário
    results.vulnerabilities.forEach(vuln => {
      results.summary[vuln.severity || 'low']++;
    });

    // Gerar relatório
    const reportPath = './pentest-report.json';
    await fs.writeFile(reportPath, JSON.stringify(results, null, 2));
    
    // Exibir sumário
    console.log('\n=== Sumário do Teste de Penetração ===');
    console.log(`Vulnerabilidades críticas: ${results.summary.high}`);
    console.log(`Vulnerabilidades médias: ${results.summary.medium}`);
    console.log(`Vulnerabilidades baixas: ${results.summary.low}`);
    console.log(`\nRelatório detalhado salvo em: ${reportPath}`);

    return results;

  } catch (error) {
    console.error('Erro durante os testes de penetração:', error);
    throw error;
  }
}

// Executar testes se chamado diretamente
if (require.main === module) {
  runPenetrationTests().catch(console.error);
}

module.exports = { runPenetrationTests }; 